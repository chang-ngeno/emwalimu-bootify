/*
 * Created on $today.date ( Time $today.time )
 * Generated by $generator.name ( version $generator.version )
 */
#set ( $uncapitalizedEntityName = ${fn.uncapitalize($entity.name)})
## 
#set ( $sqlFindAttribs = "" )
#set ( $sqlUpdateAttribs = "" )
#set ( $sqlCreateAttribs = "" )
#set ( $modelRows = "" )
#set ( $sqlInsertValues = "" )
#set ( $sqlInsertValuesWithId = "" )
#set ( $sqlRequestAttribs = "" )
#set ( $sqlParamsAttribs = "" )
#set ( $sqlRequest2CreateAttribs = "" )
#set ( $sqlPrimaryKeyParams = "" )
##
#foreach( $attrib in $entity.attributes )
#if ( $foreach.count > 1 )
#set ( $sqlFindAttribs = $sqlFindAttribs + ", " )
#end
#set ( $sqlFindAttribs = $sqlFindAttribs + ${fn.uncapitalize($attrib.name)} )
#end
##
#foreach( $attrib in $entity.attributes )
#if ( !$entity.keyAttributes.contains($attrib) )
#if ( !$sqlUpdateAttribs.equals("") )
#set ( $sqlUpdateAttribs = $sqlUpdateAttribs + ", " )
#end
#set ( $sqlUpdateAttribs = $sqlUpdateAttribs + ${fn.uncapitalize($attrib.name)} )
#set ( $sqlUpdateAttribs = $sqlUpdateAttribs + "=${DOLLAR}${fn.uncapitalize($attrib.name)}" )
#end
#end
##
#foreach( $attrib in $entity.attributes )
#if ( !$entity.keyAttributes.contains($attrib) )
#if ( !$sqlCreateAttribs.equals("") )
#set ( $sqlCreateAttribs = $sqlCreateAttribs + ", " )
#end
#set ( $sqlCreateAttribs = $sqlCreateAttribs + ${fn.uncapitalize($attrib.name)} )
#end
#end
##
#foreach( $attrib in $entity.attributes )
#if( $foreach.count > 1 )
#set ( $modelRows = $modelRows + ", " )
#end
#set ( $modelRows = $modelRows + "row." )
#set ( $modelRows = $modelRows + ${fn.uncapitalize($attrib.name)} )
#end
##
#set ( $insertCpt = 0 )
#foreach( $attrib in $entity.attributes )
#if ( !$entity.keyAttributes.contains($attrib) )
#set ( $insertCpt = $insertCpt +1 )
#if ( $insertCpt > 1 )
#set ( $sqlInsertValues = $sqlInsertValues + ", " )
#end
#set ( $sqlInsertValues = $sqlInsertValues + ${DOLLAR}+${fn.uncapitalize($attrib.name)} )
#end
#end
##
#foreach( $attrib in $entity.attributes )
#if ( $foreach.count > 1 )
#set ( $sqlInsertValuesWithId = $sqlInsertValuesWithId + ", " )
#end
#set ( $sqlInsertValuesWithId = $sqlInsertValuesWithId + ${DOLLAR}+${fn.uncapitalize($attrib.name)} )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlRequestAttribs = $sqlRequestAttribs + " AND " )
#end
#set ( $sqlRequestAttribs = $sqlRequestAttribs + ${fn.uncapitalize($key.name)} )
#set ( $sqlRequestAttribs = $sqlRequestAttribs + "=${DOLLAR}${fn.uncapitalize($key.name)}" )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlParamsAttribs = $sqlParamsAttribs + ",
			" )
#end
#set ( $sqlParamsAttribs = $sqlParamsAttribs + "${DOLLAR}${fn.uncapitalize($key.name)}: ${fn.uncapitalize($key.name)}" )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlRequest2CreateAttribs = $sqlRequest2CreateAttribs + " AND " )
#end
#set ( $sqlRequest2CreateAttribs = $sqlRequest2CreateAttribs + ${fn.uncapitalize($key.name)} )
#set ( $sqlRequest2CreateAttribs = $sqlRequest2CreateAttribs + "=${DOLLAR}id" )
#end
##
#foreach ( $key in $entity.keyAttributes)
#set ( $uncapitalizedKeyName = ${fn.uncapitalize($key.name)})
#if ($foreach.count < $entity.keyAttributes.size())
#set ( $sqlPrimaryKeyParams = $sqlPrimaryKeyParams + "${DOLLAR}${uncapitalizedKeyName} : ${entity}.${uncapitalizedKeyName}, 
            ")
#else
#set ( $sqlPrimaryKeyParams = $sqlPrimaryKeyParams + "${DOLLAR}${uncapitalizedKeyName} : ${entity}.${uncapitalizedKeyName}")
#end
#end

// Load $entity entity
const $entity = require('../model/${entity.name}');

// Load DAO Common functions
const GenericDao = require('./commons/genericDao');

// SQL Queries
const sqlSelectById = "SELECT $sqlFindAttribs FROM $uncapitalizedEntityName WHERE $sqlRequestAttribs";
const sqlSelectAll = "SELECT * FROM $uncapitalizedEntityName";
const sqlCount = "SELECT COUNT(*) AS count FROM $uncapitalizedEntityName";
const sqlUpdate = "UPDATE $uncapitalizedEntityName SET $sqlUpdateAttribs WHERE $sqlRequestAttribs";
const sqlDelete = "DELETE FROM $uncapitalizedEntityName WHERE $sqlRequestAttribs";
const sqlExist = "SELECT (count(*) > 0) as found FROM $uncapitalizedEntityName WHERE $sqlRequestAttribs";
#if ($entity.hasAutoIncrementedKey())
const sqlInsert = "INSERT into $uncapitalizedEntityName ($sqlCreateAttribs) VALUES ($sqlInsertValues)";
#else
const sqlInsert = "INSERT into $uncapitalizedEntityName ($sqlFindAttribs) VALUES ($sqlInsertValuesWithId)";
#end

/**
 * DAO of entity ${entity.name}
 */
module.exports = class ${entity.name}Dao {

    constructor() {
        this.genericDao = new GenericDao(
            sqlSelectById,
            sqlSelectAll,
            sqlCount,
		    sqlInsert,
            sqlUpdate,
            sqlDelete,
            sqlExist
        );
    }

    /**
     * Tries to find an entity using its Id / Primary Key
     * @param $fn.argumentsList($entity.keyAttributes)
     * @return entity
     */
    findById($fn.argumentsList($entity.keyAttributes)) {
       let sqlParams = {
			$sqlParamsAttribs
		};
        return this.genericDao.findOne(sqlParams)
            .then(row => {
                if(row) {
                    return new ${entity}($modelRows);
                } else {
                    return false;
                }
            })
    };

    /**
     * Finds all entities.
     * @return all entities
     */
    findAll() {
        return this.genericDao.findAll().then(rows => {
            let ${uncapitalizedEntityName}s = [];
            if (rows) {
                for (const row of rows) {
                    ${uncapitalizedEntityName}s.push(new ${entity}($modelRows));
                }
            }
            return ${uncapitalizedEntityName}s;
        });
    };

    /**
     * Counts all the records present in the database
     * @return count
     */
    countAll() {
        return this.genericDao.countAll();
    };

    /**
     * Updates the given entity in the database
     * @param $entity
     * @return true if the entity has been updated, false if not found and not updated
     */
    update($entity) {
        let sqlParams = {
#set ( $saveUpdateBodyReturn = "")
#foreach ( $attrib in $entity.attributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if ($foreach.count < $entity.attributes.size())
#if ( $attrib.isDateType() )
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
                                ")
 			${DOLLAR}${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
#else
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
                                ")
 			${DOLLAR}${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
#end
#else
#if ( $attrib.isDateType() )
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()")
 			${DOLLAR}${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()
#else
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}")
 			${DOLLAR}${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}
#end
#end
#end
        };
        return this.genericDao.update(sqlParams);
    };

    /**
     * Save the given entity in the database in case it exist, else create a new one
     * @param $entity
     * @return the updated or created entity
     */
    save($entity) {
        return this.exists($entity).then(exist => {
            if(exist) {
                return this.update($entity).then(result => {
                    if (result === true) {
                        return {
                            body:{
                                $saveUpdateBodyReturn
                            },
                            newItem: false
                        };
                    } else {
                        return result;
                    }
                });
            } else {
                return this.create($entity).then(result => {
                    if (result) {
                        return {
                            body: result,
                            newItem: true
                        };
                    } else {
                        return result;
                    }
                });
            }
        });
    };

    /**
     * Creates the given entity in the database
     * @param $entity
     * returns database insertion status
     */
    create($entity) {
        let sqlParams = {
#if ($entity.hasAutoIncrementedKey())
#foreach ( $attrib in $entity.nonKeyAttributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if ($foreach.count < $entity.nonKeyAttributes.size())
#if ($attrib.isDateType())
 			${DOLLAR}${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
#else
 			${DOLLAR}${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
#end
#else
#if ($attrib.isDateType())
 			${DOLLAR}${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()
#else
 			${DOLLAR}${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}
#end
#end
#end
#else
#foreach ( $attrib in $entity.attributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if ($foreach.count < $entity.attributes.size())
#if ($attrib.isDateType())
 			${DOLLAR}${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
#else
 			${DOLLAR}${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
#end
#else
#if ($attrib.isDateType())
 			${DOLLAR}${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()
#else
 			${DOLLAR}${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}
#end
#end
#end
#end
        };

        return this.genericDao.insert(sqlParams)
            .then(id => {
                if (id) {
                    return {
#foreach ( $attrib in $entity.attributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if (!$attrib.isAutoIncremented())
#if ($attrib.isDateType())
 					    ${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()#if($foreach.count < $entity.attributes.size()),#else#end

#else
 					    ${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}#if($foreach.count < $entity.attributes.size()),#else#end

#end
#else
 					    ${uncapitalizedAttribName}: id#if($foreach.count < $entity.attributes.size()),#else#end

#end
#end
                  };
                } else {
                    return false;
                }
            });
    };

    /**
     * Deletes an entity using its Id / Primary Key
     * @param $fn.argumentsList($entity.keyAttributes)
     * returns database deletion status
     */
    deleteById($fn.argumentsList($entity.keyAttributes)) {
		let sqlParams = {
			$sqlParamsAttribs
		};
        return this.genericDao.delete(sqlParams);
    };

    /**
     * Deletes an entity using the entity
     * @param $entity
     * returns database deletion status
     */
    delete($entity) {
        let sqlParams = {
 			$sqlPrimaryKeyParams
        };
        return this.genericDao.delete(sqlParams);
    };

    /**
     * Returns true if an entity exists with the given Id / Primary Key
     * @param $fn.argumentsList($entity.keyAttributes)
     * returns database entry existence status (true/false)
     */
    existsById($fn.argumentsList($entity.keyAttributes)) {
		let sqlParams = {
			$sqlParamsAttribs
		};
        return this.genericDao.existsOne(sqlParams);
    };

    /**
     * Returns true if an entity exists using the entity
     * @param $entity
     * returns database entry existence status (true/false)
     */
    exists($entity) {
        let sqlParams = {
            $sqlPrimaryKeyParams
        };
        return this.genericDao.existsOne(sqlParams);
    };
};