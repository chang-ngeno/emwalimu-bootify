/*
 * Created on $today.date ( Time $today.time )
 * Generated by $generator.name ( version $generator.version )
 */

// Load bluebird Promise
const Promise = require('bluebird');

/**
 * DAOs Common functions
 */
module.exports = class GenericDAO {

    constructor(
        sqlSelectById, 
        sqlSelectAll, 
        sqlCount,
		sqlInsert, 
        sqlUpdate, 
        sqlDelete, 
        sqlExist) {
		// Load database & database configuration
        this.getDatabase = require('../../config/dbCreateTables');

        this.sqlSelectById = sqlSelectById;
        this.sqlSelectAll = sqlSelectAll;
        this.sqlCount = sqlCount;
		this.sqlInsert = sqlInsert;
        this.sqlUpdate = sqlUpdate;
        this.sqlDelete = sqlDelete;
        this.sqlExist = sqlExist;
    }

    /**
     * Execute the findAll query
     * @param sqlRequest
     * @returns Promise
     */
    findAll() {
        return new Promise(function (resolve, reject) {
            this.getDatabase().all(this.sqlSelectAll, function (err, rows) {
                if (err) {
                    reject(err);
                } else {
                    resolve(rows);
                }
            });
        }.bind(this));
    }

    /**
     * Execute the findOne query
     * @param sqlRequest, sqlParams
     * @returns Promise
     */
    findOne(sqlParams) {
        return new Promise(function (resolve, reject) {
            let findQuery = this.getDatabase().prepare(this.sqlSelectById);
            findQuery.all(sqlParams, function (err, rows) {
                if (err) {
                    reject(err);
                } else if (rows === null || rows.length === 0) {
                    resolve(null);
                } else {
                    let row = rows[0];
                    resolve(row);
                }
            })
        }.bind(this));
    }

    /**
     * Execute the sqlCount query
     * @returns Promise
     */
    countAll() {
        return new Promise(function (resolve, reject) {
            this.getDatabase().all(this.sqlCount, function (err, count) {
                console.log('this is count : ', count);
                console.log('this is err : ', err);
                if (err) {
                    reject(err);
                } else {
                    resolve(count);
                }
            });
        }.bind(this));
    }

    /**
     * Execute the existOne query
     * @param sqlRequest, sqlParams
     * @returns Promise
     */
    existsOne(sqlParams) {
        return new Promise((resolve, reject) => {
            let existQuery = this.getDatabase().prepare(this.sqlExist);
            existQuery.each(sqlParams, function (err, row) {
                if (err) {
                    reject(err);
                } else if (row && row.found === 1) {
                    resolve(true);
                } else {
                    resolve(false);
                }
            })
        });
    }

    /**
     * Execute the insert query
     * @param sqlRequest, sqlParams, sqlRequest2
     * @returns Promise
     */
    insert(sqlParams) {
        return new Promise(function (resolve, reject) {
            let insertQuery = this.getDatabase().prepare(this.sqlInsert);
            
            /* Abort due to constraint violation
             * List of errorno : https://sqlite.org/c3ref/c_abort.html
             */
            let CONSTRAINT_DUPLICATE_KEY = 19;

            insertQuery.run(sqlParams, function (err) {
                // if changes happen in databse
                if (this.changes === 1) {
                    resolve(this.lastID);
                } else {
                    if (err.errno === CONSTRAINT_DUPLICATE_KEY) {
                        resolve(null);
                    } else {
                        reject(err);
                    }
                }
            });
        }.bind(this));
    }

    /**
     * Execute the update query
     * @param sqlRequest, sqlParams
     * @returns Promise
     */
    update(sqlParams) {
        return new Promise(function (resolve, reject) {
            let updateQuery = this.getDatabase().prepare(this.sqlUpdate);

            updateQuery.run(sqlParams, function (err) {
                if (err) {
                    reject(err);
                } else if (this.changes === 1) {
                    resolve(true);
                } else {
                    resolve(false);
                }
            });
        }.bind(this));
    }

    /**
     * Execute the delete query
     * @param sqlRequest, sqlParams
     * @returns Promise
     */
    delete(sqlParams) {
        return new Promise(function (resolve, reject) {
            let deleteQuery = this.getDatabase().prepare(this.sqlDelete);

            deleteQuery.run(sqlParams, function (err) {
                if (err) {
                    reject(err);
                } else if (this.changes === 1) {
                    resolve(true);
                } else {
                    resolve(false);
                }
            });
        }.bind(this));
    }
};